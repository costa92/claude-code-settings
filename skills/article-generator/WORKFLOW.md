# Article Generator - 详细工作流程

本文档详细说明了 article-generator 的完整工作流程，包括标准流程、快速模式和各种使用场景。

> **提示**: 这是详细流程文档。如需快速了解，请查看 [SKILL.md](./SKILL.md)

---

## 📋 目录

- [标准文章生成流程](#标准文章生成流程)
- [快速模式（仅文章）](#快速模式仅文章)
- [预写作验证清单](#预写作验证清单)
- [用户交互指南](#用户交互指南)
- [图片生成工作流](#图片生成工作流)
- [最佳实践](#最佳实践)
- [常见场景示例](#常见场景示例)

---

## 标准文章生成流程

**⚠️ CRITICAL: 你必须执行实际的工具调用（Write、Shell）来完成每个步骤。仅在聊天中显示内容是不够的。**

### 流程图

```
1. 明确需求
   ├─ 主题和范围
   ├─ 目标受众（初学者/开发者/架构师）
   ├─ 文章长度（~2000-3000 字推荐）
   └─ 图片需求（封面 + 节奏图）

2. 研究 & 验证（强制性）
   ├─ WebSearch 查找官方文档
   ├─ 验证所有工具/命令存在
   ├─ 在沙箱中测试命令（如果可能）
   └─ 向用户报告已验证/未验证项目

3. 内容生成
   ├─ YAML frontmatter
   ├─ 文章结构和标题
   ├─ 代码示例（可运行、完整）
   ├─ Obsidian callouts 用于关键信息
   └─ 明确的参考链接

4. 💾 保存文章到文件（强制性 - 不可跳过）
   ├─ 从文章标题生成文件名（如 "kimi-k25-claude-code.md"）
   ├─ 使用 Write 工具保存内容到文件
   ├─ 向用户确认文件路径（如 "./kimi-k25-claude-code.md"）
   └─ 绝不只在聊天中显示内容而不保存文件

5. 🎨 图片生成（如果请求）
   ├─ 重要：使用 Shell(command="realpath filename.md") 获取绝对路径
   ├─ 创建 images/ 目录：mkdir -p images
   ├─ 生成唯一的文件名前缀（如 article_slug_）
   ├─ 使用 Shell 工具调用 generate_and_upload_images.py（使用绝对路径）
   ├─ 示例：python3 /home/hellotalk/.claude/skills/article-generator/scripts/generate_and_upload_images.py --process-file /absolute/path/to/article.md
   ├─ 生成封面（16:9: 1344x768）
   ├─ 生成节奏图（3:2: 1248x832）
   ├─ 上传所有图片到 PicGo/CDN
   ├─ 使用 CDN URLs 更新文章文件
   └─ 成功上传后自动删除本地文件

6. 最终审查
   ├─ 验证所有链接正常（HTTP 200）
   ├─ 确认所有代码示例完整
   ├─ 检查没有 AI 陈词滥调或营销废话
   └─ 确保 YAML frontmatter 完整
```

### 执行要求

- **步骤 4（保存到文件）是不可协商的** - 你必须调用 Write 工具
- **步骤 5（图片生成）需要实际的 Shell 命令执行**
- **如果你只显示内容而不保存文件，任务就是不完整的**

---

## 快速模式（仅文章）

适用于想要**先写文章，稍后添加图片**的用户。

### 流程图

```
1. 明确需求
   ├─ 主题和范围
   ├─ 目标受众
   ├─ 文章长度
   └─ 确认："暂时跳过图片"

2. 研究 & 验证（强制性）
   ├─ 与标准流程相同
   └─ 报告已验证/未验证项目

3. 内容生成（仅文章）
   ├─ YAML frontmatter
   ├─ 文章结构和标题
   ├─ 代码示例（可运行、完整）
   ├─ Obsidian callouts
   ├─ 图片占位符（见下文）
   └─ 明确的参考链接

4. 💾 保存文章到文件（强制性）
   ├─ 从标题生成文件名
   ├─ 使用 Write 工具保存到文件
   ├─ 向用户确认文件路径
   └─ 在保存的文件中包含图片占位符

5. 稍后添加图片（可选）
   ├─ 使用 generate_and_upload_images.py --process-file
   ├─ 脚本将解析占位符并生成图片
   ├─ 自动上传到 CDN
   └─ 脚本将使用 CDN URLs 更新文件
```

### 图片占位符语法

在文章中使用此格式标记图片位置：

```markdown
<!-- IMAGE: cover - 封面图 (16:9) -->
<!-- PROMPT: Modern software development workflow, minimalist illustration -->

<!-- IMAGE: pic1 - 架构示意图 (3:2) -->
<!-- PROMPT: Microservices architecture diagram, flat design, technical illustration -->
```

### 快速模式的优点

- ✅ 更快的初稿（无需等待图片生成）
- ✅ 首先关注内容质量
- ✅ 稍后轻松定位和替换占位符
- ✅ 保留提示词用于未来生成

### 何时使用快速模式

- 紧迫的截止日期（发布无图片的草稿）
- 对图片风格/需求不确定
- 在移动设备/有限带宽上写作
- 稍后为多篇文章批量生成图片

---

## 预写作验证清单

**关键**: 在写任何文章之前，完成此验证清单。缺少任何步骤会导致文章被拒绝。

---

### 🎚️ 验证模式选择

根据文章用途和时间要求，选择合适的验证级别：

#### 模式 1: 标准模式 (推荐) ⭐

**适用场景**:
- 正式发布的技术博客
- 公开分享的教程文章
- 团队协作的技术文档

**验证内容**:
- ✅ 核心工具和命令验证
- ✅ 代码完整性检查
- ✅ 主要链接验证
- ⚠️ 补充链接建议验证
- ⚠️ 白名单工具基本命令信任

**预计时间**: 正常生成时间

**质量保证**: 高 (95%+ 准确率)

---

#### 模式 2: 快速模式 (草稿)

**适用场景**:
- 内部文档草稿
- 个人学习笔记
- 快速原型文章
- 时间紧迫的场景

**验证内容**:
- ✅ 仅验证非白名单工具
- ✅ 核心代码完整性
- ❌ 跳过链接验证
- ❌ 跳过白名单工具验证
- ❌ 跳过补充内容验证

**预计时间**: 比标准模式快 **40-50%**

**质量保证**: 中 (85%+ 准确率)

**适合后续优化**: 可以稍后用标准模式重新生成

---

#### 模式 3: 严格模式 (高质量)

**适用场景**:
- 官方技术文档
- 对外发布的教程
- 高质量要求的文章
- 企业级文档

**验证内容**:
- ✅ 所有工具和命令验证 (包括白名单)
- ✅ 所有链接验证 (包括补充链接)
- ✅ 代码沙箱测试 (如可能)
- ✅ 版本兼容性检查
- ✅ 多平台支持验证

**预计时间**: 比标准模式慢 **30-40%**

**质量保证**: 极高 (99%+ 准确率)

---

### 📊 验证模式对比

| 维度 | 快速模式 | 标准模式 ⭐ | 严格模式 |
|------|---------|-----------|---------|
| **验证工具** | 仅非白名单 | 核心工具 | 所有工具 |
| **验证命令** | 核心命令 | 核心命令 | 所有命令 |
| **验证链接** | ❌ 跳过 | 主要链接 | 所有链接 |
| **代码检查** | 完整性 | 完整性 + 可运行性 | 完整 + 测试 |
| **生成时间** | 快 (60%) | 标准 (100%) | 慢 (140%) |
| **准确率** | 85%+ | 95%+ | 99%+ |
| **推荐场景** | 草稿/笔记 | 技术博客 | 官方文档 |

---

### 🎯 如何选择验证模式

**决策流程**:

```
是否需要公开发布？
├─ 是 → 是否是官方文档？
│        ├─ 是 → 严格模式
│        └─ 否 → 标准模式 (默认)
└─ 否 → 是否时间紧迫？
         ├─ 是 → 快速模式
         └─ 否 → 标准模式
```

**示例**:
- 个人博客技术文章 → **标准模式**
- 公司官方教程 → **严格模式**
- 内部学习笔记 → **快速模式**
- 开源项目 README → **标准模式**
- 快速概念验证 → **快速模式**

---

### ⚙️ 如何指定验证模式

**在生成时告知 AI**:

```
# 标准模式 (默认，无需说明)
@article-generator 写一篇 Docker 教程

# 快速模式
@article-generator 写一篇 Docker 教程 (快速草稿模式)

# 严格模式
@article-generator 写一篇 Docker 教程 (需要严格验证)
```

**AI 会自动调整验证级别**

---

### 验证哲学

**核心原则：验证先行，绝不编造**

所有技术内容必须满足以下之一：
1. ✅ **官方文档验证**（最可靠）- 通过 WebSearch/WebFetch 找到官方文档
2. ✅ **受信任工具白名单**（预验证）- 广泛使用的稳定工具
3. ✅ **用户提供的信息**（需确认）- 用户明确提供并确认可靠
4. ✅ **知识库内的可靠信息**（适度信任）- 训练数据中的稳定知识（见下方说明）

**不满足任何条件的内容：**
- ❓ 标记为 "[需要验证]" 并询问用户
- ❌ 或直接从文章中移除
- ❌ **绝不编造或猜测**

**关于知识库信息的使用：**
- ✅ 可信任：基础概念、算法原理、编程语言基础语法、经典设计模式
- ✅ 可信任：HTTP、TCP/IP 等标准协议的基本概念
- ⚠️ 需验证：工具的具体命令、API 调用方式、配置文件格式
- ⚠️ 需验证：版本特定功能、最新发布的工具、快速变化的技术
- ❌ 不可信任：2024 年后的新工具、新版本特性（必须通过 WebSearch 验证）

**验证力度平衡：**
- 基础理论知识可以适度信任（如"Docker 是容器化技术"）
- 但具体实现细节必须验证（如"docker run 的具体参数"）

---

### 受信任工具白名单（跳过验证）

以下广泛使用的工具是**预先验证的** - 基本命令无需 WebSearch：

**开发工具:**
- Docker, Kubernetes, Git, npm, yarn, pnpm, pip, cargo, Maven, Gradle
- Node.js, Python, Go, Rust, Java, TypeScript, Ruby

**操作系统 & 包管理器:**
- apt, yum, dnf, brew, pacman, apk, snap

**常见 CLI 工具:**
- curl, wget, ssh, scp, rsync, grep, sed, awk, tar, gzip

**为什么需要白名单？** 这些工具有稳定的 API 和广泛的官方文档。可以信任它们的基本命令。

**何时仍需验证：**
- 小众标志或选项（如 `docker run --gpus` 需要验证）
- 版本特定功能（如 "Docker 24.0+ only"）
- 已弃用的命令
- 任何你不确定的命令

**验证效率优化：**
- ✅ 对于白名单工具的常用场景（如 `docker run -d`, `git clone`, `npm install`），无需每次都验证
- ✅ 如果最近（同一会话）已验证过某个工具，无需重复验证
- ⚠️ 但如果用户提出非常规用法，仍需验证

**验证缓存机制：**
- 同一会话内，已验证的工具/命令可以记住
- 示例：如果已经验证了 Docker 的 `run` 命令，后续使用相同命令无需再验证
- 但如果是新的参数组合（如 `--gpus`），仍需验证
- 2023 年后新增的功能或参数

**验证优先级：**
1. **高优先级**（必须验证）：具体命令、参数、配置项、API 调用
2. **中优先级**（建议验证）：工作流步骤、最佳实践、性能优化建议
3. **低优先级**（可以信任）：基础概念、通用原理、语言基础语法

---

### 验证步骤详解

#### 步骤 1: 工具/项目研究（对于非白名单工具是强制性的）

**目标：确认工具真实存在，理解实际功能**

1. **快速判断：是否需要深度验证**
   - 如果工具非常知名且版本稳定（如 Python 3.x 基础语法）→ 可以适度信任基础用法
   - 如果工具较新或不熟悉 → 必须进行完整验证
   - 如果涉及具体命令参数 → 始终需要验证

2. **使用 WebSearch 查找官方来源**
   ```
   WebSearch(search_term="[tool_name] official documentation")
   WebSearch(search_term="[tool_name] GitHub repository")
   ```

3. **验证工具真实性**
   - 检查官方网站是否存在
   - 确认 GitHub 仓库（星标数、最后更新时间）
   - 阅读 README 了解功能范围

4. **理解实际功能**
   - ❌ 不要根据工具名称推测功能
   - ❌ 不要根据"常识"假设用法
   - ✅ 必须从官方文档确认所有功能

**高效验证策略：**
- 对于白名单工具的基础命令 → 跳过验证，直接使用
- 对于白名单工具的高级参数 → 快速验证（查看 man 页面或官方文档）
- 对于非白名单工具 → 完整验证流程
- 对于完全陌生的工具 → 询问用户提供文档链接，避免盲目搜索

**示例验证流程：**

```
场景 A: 白名单工具 + 基础命令
用户请求："写一篇 Git 基础教程"
✅ 快速路径：Git 在白名单，基础命令（clone, pull, push）无需验证
处理：直接生成文章，包含基础命令

场景 B: 白名单工具 + 高级参数
用户请求："写一篇 Docker GPU 加速的文章"
⚠️ 验证路径：Docker 在白名单，但 --gpus 参数需要验证
处理：
   1. WebSearch("docker run --gpus official documentation")
   2. 确认参数存在、版本要求、使用示例
   3. 生成文章时注明版本要求

场景 C: 非白名单工具
用户请求："写一篇关于 XYZ 工具的文章"
❌ 错误做法：直接开始写，根据名称猜测
✅ 完整验证：
   1. WebSearch("XYZ tool official documentation")
   2. WebFetch(找到的官方文档 URL)
   3. 确认：工具存在、功能、安装方法、使用示例
   4. 如果找不到可靠信息 → 询问用户提供文档链接

场景 D: 完全陌生的工具
用户请求："写一篇关于 SuperObscureTool 的文章"
🤔 最优策略：
   1. 快速搜索一次：WebSearch("SuperObscureTool")
   2. 如果没有明显结果 → 直接询问用户：
      "我不熟悉 SuperObscureTool，请提供以下信息之一：
      - 官方文档链接
      - GitHub 仓库链接
      - 工具的正确名称（是否有拼写错误？）"
   3. 避免盲目搜索浪费时间
```

**项目消歧（如果找到多个同名项目）：**

```
找到 3 个名为 "XYZ" 的项目：

1. **owner1/xyz** (1.2k stars, 活跃维护)
   - 功能: CLI 自动化工具
   - URL: https://github.com/owner1/xyz

2. **owner2/XYZ** (500 stars, 6 个月未更新)
   - 功能: Web 开发框架
   - URL: https://github.com/owner2/XYZ

3. **owner3/xyz-tool** (50 stars, 个人项目)
   - 功能: Python 脚本集合
   - URL: https://github.com/owner3/xyz-tool

请确认您指的是哪一个项目？
```

---

#### 步骤 2: 命令/功能验证（强制性）

**目标：确保文章中的每个命令都在官方文档中存在**

1. **命令存在性验证**
   - ✅ 在官方文档中找到该命令
   - ✅ 参数、选项与官方文档一致
   - ✅ 命令从官方文档复制（不是发明的）
   - ❌ 无法找到文档 → 该命令不存在，不要包含

2. **代码示例验证**
   - ✅ 代码是完整的、可运行的
   - ✅ API 用法与官方示例一致
   - ✅ 依赖版本明确标注
   - ❌ 编造的代码 → 拒绝文章

3. **配置文件验证**
   - ✅ 配置项在官方文档中存在
   - ✅ 值的格式正确（字符串、数字、布尔值）
   - ❌ 猜测的配置项 → 拒绝

**示例：正确 vs 错误**

```markdown
❌ 错误（编造的命令）：
```bash
# 这个命令不存在于官方文档
docker magic-deploy --auto-scale --with-ai
```

❌ 错误原因：
- 命令是编造的
- 参数不存在
- 没有官方文档支持

✅ 正确（验证过的命令）：
```bash
# Docker 官方文档：https://docs.docker.com/engine/reference/run/
docker run -d --name myapp -p 80:80 nginx:latest
```

✅ 正确原因：
- 命令从官方文档复制
- 参数有文档支持
- 标注了文档来源
```

**白名单工具的例外：**
- Docker, Git, npm 等白名单工具的**基本命令**可以信任
- 但**高级选项**仍需验证
- 示例：
  - ✅ `docker run -d nginx` - 基本命令，可信任
  - ❓ `docker run --gpus all` - 高级选项，需验证

---

#### 步骤 3: 工作流验证（强制性）

**目标：确保多步骤教程的每一步都可靠**

1. **步骤完整性**
   - 每一步都有官方文档或可靠来源
   - 没有"应该能工作"的假设步骤
   - 步骤顺序经过验证

2. **依赖关系验证**
   - 前置条件明确列出
   - 版本兼容性已确认
   - 环境要求已说明

3. **潜在问题处理**
   - 如果某步不确定 → 标记 "[需要验证]"
   - 询问用户确认或提供补充信息
   - 绝不用"合理假设"填补空白

**示例：可靠的多步骤教程**

```markdown
❌ 错误（假设的步骤）：

### 安装和使用 XYZ 工具

1. 安装工具
   ```bash
   npm install xyz  # 假设是 npm 包？
   ```

2. 运行工具
   ```bash
   xyz magic-command  # 编造的命令
   ```

3. 应该就能工作了  # 模糊不清，没有验证

---

✅ 正确（验证过的步骤）：

### Docker 容器化快速入门

**前置条件：**
- Ubuntu 20.04+ 或等效系统
- 具有 sudo 权限的用户
- 至少 4GB 可用磁盘空间

**步骤 1: 安装 Docker (v20.10+)**
```bash
# 官方文档: https://docs.docker.com/engine/install/ubuntu/
sudo apt update
sudo apt install -y docker.io
```

**步骤 2: 验证安装**
```bash
docker --version
# 预期输出: Docker version 20.10.x, build xxxxx
```

**步骤 3: 拉取官方镜像**
```bash
# 官方镜像列表: https://hub.docker.com/_/nginx
docker pull nginx:latest
```

**步骤 4: 运行容器**
```bash
# 参数说明: https://docs.docker.com/engine/reference/run/
docker run -d -p 80:80 --name my-nginx nginx:latest
```

**步骤 5: 验证运行**
```bash
curl http://localhost
# 预期输出: Nginx 欢迎页面 HTML
```

✅ 正确原因：
- 每一步都有官方文档链接
- 前置条件明确
- 预期输出清晰
- 命令都经过验证
```

---

#### 步骤 4: 链接验证（建议性）

**目标：确保重要链接可访问**

**验证优先级：**
1. **必须验证**（生成文章前）
   - 官方文档的主页链接
   - GitHub 仓库的主页链接
   - 文章中明确引用的关键参考资料

2. **建议验证**（时间允许时）
   - 具体 API 文档页面
   - 教程链接
   - 博客文章链接

3. **可以跳过**（降低工作量）
   - 众所周知的域名（docs.docker.com, github.com 等）
   - 标准文档结构的链接（如 `/docs/`, `/api/` 等）

**验证方法：**
```
# 高价值链接：使用 WebFetch 完整验证
WebFetch(url="https://new-tool.com/docs")  # 新工具的文档

# 知名网站：跳过验证或简单检查
# https://docs.docker.com/ → 可以信任，无需验证
```

**链接类型要求：**
- ✅ 官方文档链接（优先）
- ✅ GitHub 官方仓库
- ✅ 经验证的技术博客
- ⚠️ 404 错误链接 → 移除或替换（如果验证时发现）
- ❌ 编造的 URL → 拒绝文章

**链接格式规范：**
- 使用明确格式：`**名称**: https://url`
- 不使用 `[[Obsidian links]]`（除非用户明确要求）
- 链接标题清晰描述内容

**平衡效率与质量：**
- 不要为每个链接都运行 WebFetch（太耗时）
- 重点验证新工具、不熟悉网站的链接
- 对于知名网站（Docker 官网、GitHub 等）可以信任链接结构

**示例：**

```markdown
❌ 错误：
- [官方文档](https://example.com/404)  # 链接失效
- [[Internal Link]]  # 不适合技术博客
- https://random-blog.com/post  # 不可靠来源

✅ 正确：
- **Docker 官方文档**: https://docs.docker.com/
- **Nginx GitHub 仓库**: https://github.com/nginx/nginx
- **Ubuntu 安装指南**: https://ubuntu.com/server/docs
```

---

#### 步骤 5: 预生成报告（强制性）

**目标：向用户透明展示验证结果，确认是否继续**

生成文章前，向用户展示验证报告：

```markdown
## 📋 内容验证报告

### ✅ 已验证工具（通过官方文档）
- **Docker** 
  - 官方文档: https://docs.docker.com/
  - 验证内容: 安装命令、run 参数、网络配置
  
- **Nginx**
  - 官方文档: https://nginx.org/en/docs/
  - 验证内容: 配置文件语法、常用指令

### ✅ 受信任工具（白名单）
- Git (基本命令: clone, pull, push)
- npm (基本命令: install, run, build)
- curl (HTTP 请求测试)

### ❓ 需要验证的内容
- **[工具X]** 的高级配置选项
  - 原因: 未找到官方文档中关于该选项的说明
  - 建议: 省略该部分或请用户提供可靠来源

- **[步骤Y]** 在 macOS 上的兼容性
  - 原因: 官方文档仅提供 Linux 示例
  - 建议: 仅包含 Linux 步骤，或标注"macOS 未验证"

### 📝 处理建议
1. 已验证内容将包含在文章中
2. 未验证内容有以下选项：
   - 选项 A: 省略这些部分
   - 选项 B: 标记为 "[需要验证]" 保留
   - 选项 C: 用户提供可靠来源后再包含

**是否继续生成文章？请选择处理方式（A/B/C）**
```

**只有在以下情况才继续生成：**

1. ✅ 用户确认了未验证项目的处理方式
2. ✅ 或者已移除所有未验证内容
3. ✅ 或者用户提供了额外的可靠来源

---

### 执行规则（严格执行）

**零容忍政策：**

| 情况 | 处理方式 | 示例 |
|------|---------|------|
| ❌ 编造的命令 | **拒绝整篇文章** | `tool magic-deploy --auto` |
| ❌ 编造的配置项 | **拒绝整篇文章** | `config.enableAI: true` (不存在的配置) |
| ❌ 未验证的声明 | **询问用户或省略** | "XYZ 工具比 ABC 快 10 倍" (无来源) |
| ❌ 404 链接 | **移除或替换** | 失效的文档链接 |
| ❓ 不确定的步骤 | **标记或询问** | "[需要验证] 此步骤在 Windows 上可能不同" |
| ❓ 有疑问的内容 | **询问，绝不猜测** | 无法确认某个参数的作用 |

**验证失败处理示例：**

```
场景 1: 工具不存在

用户："写一篇关于 SuperTool 的文章"

验证结果：
- WebSearch("SuperTool official documentation") → 无结果
- WebSearch("SuperTool GitHub") → 无结果

处理方式：
❌ 错误: 根据名称猜测功能并开始写
✅ 正确: "抱歉，我无法找到 'SuperTool' 的官方文档或可靠信息。
         请提供以下之一：
         1. 官方文档链接
         2. GitHub 仓库链接
         3. 更正确的工具名称"

---

场景 2: 找到多个同名项目

用户："写一篇关于 XYZ 的文章"

验证结果：
- 找到 3 个不同的 XYZ 项目

处理方式：
❌ 错误: 随便选一个开始写
✅ 正确: 
   "找到 3 个名为 XYZ 的项目：
   1. owner1/xyz (1.2k stars) - CLI 工具
   2. owner2/XYZ (500 stars) - Web 框架
   3. owner3/xyz-tool (50 stars) - Python 库
   
   您指的是哪一个？"

---

场景 3: 命令无法验证

用户："包含 docker magic-deploy 命令"

验证结果：
- 官方文档中无此命令
- GitHub issues 无相关讨论

处理方式：
❌ 错误: 假设命令存在并包含在文章中
✅ 正确:
   "在 Docker 官方文档中未找到 'docker magic-deploy' 命令。
   请确认：
   1. 这是自定义脚本吗？
   2. 是否指的是其他命令？(如 docker deploy)
   3. 来源是什么？(插件、第三方工具等)
   
   如果无法验证，建议省略此命令。"
```

---

### 快速验证检查清单

**生成文章前，确保完成所有检查项：**

- [ ] **工具验证**
  - [ ] 所有非白名单工具已通过 WebSearch/WebFetch 验证
  - [ ] 工具的实际功能与描述一致
  - [ ] 多个同名项目已消歧，用户已确认

- [ ] **命令验证**
  - [ ] 每个命令在官方文档中存在
  - [ ] 命令参数与官方文档一致
  - [ ] 白名单工具的高级选项已验证

- [ ] **代码验证**
  - [ ] 所有代码示例完整可运行
  - [ ] API 用法与官方文档一致
  - [ ] 依赖版本明确标注

- [ ] **链接验证**
  - [ ] 所有链接已通过 WebFetch 验证（HTTP 200）
  - [ ] 链接指向官方或可靠来源
  - [ ] 无失效链接（404）

- [ ] **工作流验证**
  - [ ] 多步骤教程每一步都有文档支持
  - [ ] 前置条件明确列出
  - [ ] 没有假设或猜测的步骤

- [ ] **用户确认**
  - [ ] 已向用户展示验证报告
  - [ ] 用户已确认未验证内容的处理方式
  - [ ] 或已移除所有未验证内容

**完成度要求（灵活处理）：**
- ✅ **核心检查项**（必须完成）：工具验证、命令验证、代码验证
- ⚠️ **建议检查项**（尽量完成）：所有链接验证
- 💡 **效率优化**：对于白名单工具和知名网站，可以适度信任

**判断原则：**
- 如果文章核心内容（命令、代码）无法验证 → 不要生成文章
- 如果仅是部分链接无法验证 → 可以继续，但标注"链接未验证"
- 如果有任何疑问 → 询问用户，绝不猜测

**目标：在保证内容质量的前提下，提高生成效率**

---

## 用户交互指南

### 强制性：对所有用户决策使用 AskQuestion 工具

生成文章时，你必须使用 `AskQuestion` 工具收集用户需求和偏好。这提供了清晰、结构化的交互体验。

**核心原则：渐进式交互**
- ✅ 一次问一个问题
- ✅ 在继续之前等待用户响应
- ✅ 每个问题应该有 2-4 个带描述的清晰选项
- ✅ 根据先前的答案调整后续问题
- ❌ 绝不在单条文本消息中问所有问题

### 何时使用 AskQuestion

#### 场景 1: 初始需求收集
文章生成开始时，收集：
1. 主题和范围
2. 目标受众
3. 文章长度/深度
4. 图片需求

#### 场景 2: 模糊的内容决策
当你遇到：
- 多个有效的实现方法
- 不确定的技术细节
- 用户请求中缺少的信息
- 需要在写作风格之间选择

#### 场景 3: 图片生成工作流
生成图片前，确认：
- 图片风格和格式
- 需要的图片数量
- 是立即生成还是使用占位符

#### 场景 4: 错误处理和重试
当问题发生时：
- 图片生成超时/失败
- PicGo 上传错误
- 验证失败

### 问题模板示例

#### 示例 1: 目标受众选择
```javascript
AskQuestion({
  questions: [{
    id: "audience",
    prompt: "这篇文章的目标读者是？",
    options: [
      {
        id: "beginner",
        label: "初学者 - 需要详细的基础知识和步骤说明"
      },
      {
        id: "developer",
        label: "开发者 - 需要代码示例和最佳实践"
      },
      {
        id: "architect",
        label: "架构师 - 需要设计思路和性能分析"
      }
    ]
  }]
})
```

#### 示例 2: 文章长度
```javascript
AskQuestion({
  questions: [{
    id: "length",
    prompt: "期望的文章篇幅？",
    options: [
      {
        id: "quick",
        label: "快速入门（500-1000字）- 15分钟阅读，核心概念介绍"
      },
      {
        id: "tutorial",
        label: "实战教程（2000-3000字）- 完整代码示例和实践步骤"
      },
      {
        id: "deep",
        label: "深度解析（4000+字）- 原理剖析、性能优化、最佳实践"
      }
    ]
  }]
})
```

#### 示例 3: 图片生成决策
```javascript
AskQuestion({
  questions: [{
    id: "images",
    prompt: "如何处理文章配图？",
    options: [
      {
        id: "generate",
        label: "立即生成（封面 + 节奏图）- 自动生成并上传到CDN，一步完成"
      },
      {
        id: "placeholder",
        label: "仅占位符（稍后添加）- 文章中使用HTML注释占位，可后续批量生成"
      },
      {
        id: "none",
        label: "纯文字文章 - 不需要配图"
      }
    ]
  }]
})
```

---

## 图片生成工作流

### 方法 1: 从配置文件批量生成（推荐）

#### 步骤 1: 创建图片配置 JSON

```json
{
  "images": [
    {
      "name": "封面图",
      "prompt": "Modern AI technology, neural network visualization, blue and purple gradient, professional tech style",
      "size": "1344x768",
      "aspect_ratio": "16:9",
      "filename": "ai_article_cover.jpg"
    },
    {
      "name": "架构图",
      "prompt": "System architecture diagram, microservices, containers, cloud infrastructure, technical illustration",
      "size": "1248x832",
      "aspect_ratio": "3:2",
      "filename": "ai_article_pic1.jpg"
    }
  ]
}
```

#### 步骤 2: 执行批量生成

```bash
python3 /home/hellotalk/.claude/skills/article-generator/scripts/generate_and_upload_images.py \
  --config images_config.json \
  --output-dir ./images \
  --resolution 2K
```

### 方法 2: 从 Markdown 文件自动处理（推荐用于已有文章）

**重要：必须使用绝对路径！**

#### 步骤 1: 获取文件的绝对路径

```bash
# 错误方式（相对路径）
--process-file ./article.md  # ❌ 将失败

# 正确方式（绝对路径）
realpath article.md  # 返回: /home/hellotalk/onedrive/docs/article.md
```

#### 步骤 2: 使用绝对路径执行

```bash
python3 /home/hellotalk/.claude/skills/article-generator/scripts/generate_and_upload_images.py \
  --process-file /home/hellotalk/onedrive/docs/article.md \
  --resolution 2K
```

### 方式 2: 使用 S3 兼容存储（原生支持）

从 v3.0 版本开始，支持直接上传到 AWS S3、Cloudflare R2、阿里云 OSS 等，无需安装 PicGo。

**配置方法**: 编辑 `~/.article-generator.conf`

```json
{
  "s3": {
    "enabled": true,
    "endpoint_url": "https://<accountid>.r2.cloudflarestorage.com",
    "access_key_id": "your_access_key",
    "secret_access_key": "your_secret_key",
    "bucket_name": "your-bucket",
    "public_url_prefix": "https://pub-domain.com"
  }
}
```

**依赖**: 需要安装 `boto3` 库 (脚本会自动检查)。

---

### 图片规格

**支持的尺寸：**
- 封面：1344x768 (16:9)
- 节奏图：1248x832 (3:2) 或 1152x896 (5:4)
- 方形：1024x1024 (1:1)
- 竖版：768x1344 (9:16)
- 超宽：1536x672 (21:9)
- **不支持**: 900x383（需要从 1344x768 手动裁剪）

### 重试和错误处理

- **SSL/网络错误**: 自动重试 3 次（2-3 秒延迟）
- **目录错误**: 自动修复 `mkdir -p`
- **上传失败**: 快速失败 - 任何上传错误都会停止整个工作流，以防止生成带有损坏图片链接的文章
- **其他错误**: 报告给用户，询问决定

### 进度跟踪

- 批量生成使用 tqdm 显示进度条（自动安装）
- 显示：当前图片名称、进度百分比、时间估计
- 示例：`📸 处理 2/5: 封面图 |████░░░░| 40% [00:15<00:22]`
- 如果 tqdm 不可用，回退到简单计数器

### 智能 Prompt 增强 (v3.0 新增)

使用 `--enhance` 参数，可以让 AI 自动优化简单的提示词。

- **原理**: 调用 Gemini 文本模型，将简单的描述（如 "Docker Logo"）扩写为详细的艺术指令（风格、光影、构图）。
- **用法**: `python3 ... --enhance`
- **效果**: 显著提升图片质量和细节丰富度。

---

## 最佳实践

### 写作风格

1. **无 AI 味道**: 消除营销废话、虚假互动、过度使用感叹号和 AI 陈词滥调
2. **直接和技术性**: 关注技术准确性而非可读性
3. **标题中无 emoji**: 绝不在文章标题或章节标题（# ## ###）中使用 emoji
4. **emoji 仅在 callouts 中**: 必要时在 Obsidian callouts 内可接受

### 结构

5. **需要 YAML frontmatter**: 每篇文章必须以元数据开头（title、date、tags、category、status、aliases）
6. **Obsidian callouts**: 使用 `> [!type]` 语法（abstract、info、tip、warning、note、success、quote）
7. **单个参考部分**: 末尾一个"参考链接"部分，删除重复
8. **无冗余部分**: 避免"互动环节"、"写在最后"、"下期预告"
9. **无元数据重复**: 不要在文章末尾重复 tags/date

### 代码 & 链接

10. **代码必须可运行**: 包含完整的、可执行的代码，带有类型注释、文档字符串、错误处理
11. **仅明确链接**: 使用 `**名称**: https://url` - 绝不使用 `[[双括号]]`
12. **验证所有链接**: 在包含之前使用 curl/WebFetch 确认 URLs 返回 HTTP 200
13. **技术比较**: 使用参数表（成本、延迟、内存），而不是主观评分

### 图片

14. **图片集成**: 通过 nanobanana 生成（3000 字文章 1 个封面 + 4-6 个节奏图）
15. **上传到 CDN**: 使用 PicGo 上传，嵌入 CDN URLs，删除本地文件
16. **唯一文件名**: 每篇文章必须有唯一的图片前缀（如 `ollama_cover.jpg` vs `unsloth_cover.jpg`）

### 仅文章模式

17. **占位符格式**: 使用 HTML 注释标记未来图片位置
    ```markdown
    <!-- IMAGE: cover - 封面图 (16:9) -->
    <!-- PROMPT: your image generation prompt here -->
    ```
18. **占位符位置**: 标题后封面，每 400-600 字一个节奏图
19. **保留提示词**: 始终包含 PROMPT 注释用于稍后批量生成
20. **替换工作流**: 图片准备好时使用查找-替换将占位符换成 CDN URLs

### 项目消歧

21. **当用户提到项目时**:
    - 首先使用 WebSearch 或 GitHub API 搜索
    - 如果找到多个项目：
      - 列出所有候选项目：名称、星标、描述、URL
      - 询问用户："找到 X 个名为 [name] 的项目。你指的是哪一个？"
    - 绝不假设用户指的是哪个项目

### 输出

22. **输出到当前目录**: 在用户的 pwd 中生成，而不是 skill 目录
23. **响应中的文件路径**: 显示给用户时使用相对路径（如 `./article_name.md`），但调用图片生成脚本时使用绝对路径

---

## 常见场景示例

### 场景 1: 标准技术博客（带图片）

**用户请求**: "写一篇关于 Docker 容器化的实战教程"

**工作流**:
1. ✅ 使用 AskQuestion 明确受众（开发者）
2. ✅ 使用 AskQuestion 确认长度（2000-3000字）
3. ✅ 使用 AskQuestion 确认图片（封面 + 节奏图）
4. ✅ 验证：Docker 在白名单中，基本命令可信任
5. ✅ 生成文章内容（YAML + 结构 + 代码 + callouts）
6. ✅ 使用 Write 工具保存到 `docker-containerization-guide.md`
7. ✅ 获取绝对路径：`realpath docker-containerization-guide.md`
8. ✅ 生成图片：`python3 ... --process-file /absolute/path/docker-containerization-guide.md`
9. ✅ 最终审查并向用户确认

### 场景 2: 快速草稿（无图片）

**用户请求**: "快速写一篇 Kubernetes 入门，先不要图片"

**工作流**:
1. ✅ 使用 AskQuestion 明确受众（初学者）
2. ✅ 使用 AskQuestion 确认长度（500-1000字）
3. ✅ 确认：跳过图片，使用占位符
4. ✅ 验证：Kubernetes 在白名单中
5. ✅ 生成文章内容（包含图片占位符）
6. ✅ 使用 Write 工具保存到 `kubernetes-quickstart.md`
7. ✅ 向用户确认文件路径
8. ✅ 告知用户稍后可以运行图片生成

### 场景 3: 翻译和本地化

**用户请求**: "将这个英文博客翻译成中文技术文章"

**工作流**:
1. ✅ 使用 WebFetch 获取原始内容
2. ✅ 使用 AskQuestion 明确受众和风格
3. ✅ 翻译内容，保持技术准确性
4. ✅ 调整为符合中文技术博客风格
5. ✅ 使用 Write 工具保存翻译后的文章
6. ✅ （可选）生成适合中文读者的本地化图片

### 场景 4: 批量图片生成 (增强模式)

**用户请求**: "为文章生成高质量配图"

**工作流**:
1. ✅ 获取文章绝对路径
2. ✅ 运行脚本（开启增强模式）：
   ```bash
   python3 /path/to/scripts/generate_and_upload_images.py \
     --process-file /absolute/path/to/article.md \
     --enhance
   ```
3. ✅ 脚本自动：
   - 优化 Prompt
   - 生成图片
   - 上传 CDN (PicGo 或 S3)
   - 替换链接
4. ✅ 向用户确认完成

---

## 相关文档

- **[SKILL.md](./SKILL.md)** - 核心指南和快速参考
- **[TROUBLESHOOTING.md](./TROUBLESHOOTING.md)** - 问题排查指南
- **[INSTALL.md](./INSTALL.md)** - 安装和配置
- **[references/](./references/)** - 详细的写作和图片指南

---

**最后更新**: 2026-01-31
**版本**: 1.0.0
